---
phase: 03-content-api
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/utils/slug.ts
  - backend/src/utils/file-upload.ts
autonomous: true

must_haves:
  truths:
    - "Slugs can be generated from titles"
    - "Unique slugs can be ensured against existing database entries"
    - "Files can be validated for type and size"
    - "Files can be saved to disk with UUID filenames"
  artifacts:
    - path: "backend/src/utils/slug.ts"
      provides: "generateSlug and createUniqueSlug functions"
      exports: ["generateSlug", "createUniqueSlug"]
    - path: "backend/src/utils/file-upload.ts"
      provides: "validateFile and saveFile functions"
      exports: ["validateFile", "saveFile"]
  key_links:
    - from: "backend/src/utils/slug.ts"
      to: "database"
      via: "createUniqueSlug queries for existing slugs"
      pattern: "findFirst.*slug"
---

<objective>
Create utility functions for slug generation and file upload handling.

Purpose: These utilities are shared across multiple route files (courses, research, templates). Centralizing them prevents code duplication and ensures consistent behavior.
Output: Slug utility with unique slug generation, file upload utility with validation and disk saving.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-content-api/03-RESEARCH.md
@.planning/phases/03-content-api/03-CONTEXT.md

@backend/src/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create slug utility functions</name>
  <files>
    backend/src/utils/slug.ts
  </files>
  <action>
Create slug.ts with two functions:

**generateSlug(title: string): string**
- Convert to lowercase
- Trim whitespace
- Replace non-word characters (except spaces/hyphens) with empty string
- Replace spaces/underscores with single hyphen
- Remove leading/trailing hyphens
- Example: "My Course Title!" â†’ "my-course-title"

**createUniqueSlug(baseSlug: string, tableName: 'courses' | 'researchReports'): Promise<string>**
- Import db and tables from db/index.js
- Query table to check if slug exists
- If exists, append -1, -2, etc. until unique
- Use switch/case on tableName to query the right table
- Return unique slug

Pattern from research:
```typescript
async function createUniqueSlug(baseSlug: string, tableName: 'courses' | 'researchReports'): Promise<string> {
  let slug = baseSlug
  let counter = 1

  while (true) {
    let existing: unknown
    switch (tableName) {
      case 'courses':
        existing = await db.query.courses.findFirst({
          where: eq(courses.slug, slug)
        })
        break
      case 'researchReports':
        existing = await db.query.researchReports.findFirst({
          where: eq(researchReports.slug, slug)
        })
        break
    }

    if (!existing) return slug
    slug = `${baseSlug}-${counter}`
    counter++
  }
}
```
  </action>
  <verify>
`npx tsc --noEmit` from backend/ - no TypeScript errors
  </verify>
  <done>
slug.ts exports generateSlug and createUniqueSlug, handles both courses and researchReports tables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create file upload utility functions</name>
  <files>
    backend/src/utils/file-upload.ts
  </files>
  <action>
Create file-upload.ts with constants and functions:

**Constants:**
```typescript
export const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB

export const ALLOWED_TEMPLATE_TYPES = [
  'application/pdf',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
]

export const ALLOWED_IMAGE_TYPES = [
  'image/png',
  'image/jpeg',
  'image/jpg',
  'image/webp',
]
```

**validateFile(file: File, allowedTypes: string[], maxSize: number = MAX_FILE_SIZE): { valid: boolean; error?: string }**
- Check file.size against maxSize
- Check file.type against allowedTypes
- Return { valid: true } or { valid: false, error: 'message' }
- Do NOT throw - return result object (per 02-02 decision pattern)

**saveFile(file: File, uploadDir: string): Promise<{ filename: string; filepath: string }>**
- Import randomUUID from 'crypto', writeFile and mkdir from 'fs/promises', join from 'path'
- Extract extension from file.name
- Generate filename: `${randomUUID()}.${ext}`
- Ensure directory exists: `await mkdir(uploadDir, { recursive: true })`
- Read file into buffer: `Buffer.from(await file.arrayBuffer())`
- Write file: `await writeFile(join(uploadDir, filename), buffer)`
- Return { filename, filepath: `${uploadDir}/${filename}` }

**getUploadDir(type: 'templates' | 'images' | 'thumbnails'): string**
- Return `join(process.cwd(), 'uploads', type)`

These follow the research patterns for file upload security:
- UUID filenames prevent race conditions and path traversal
- Explicit type validation
- Directory creation is idempotent
  </action>
  <verify>
`npx tsc --noEmit` from backend/ - no TypeScript errors
  </verify>
  <done>
file-upload.ts exports MAX_FILE_SIZE, ALLOWED_TEMPLATE_TYPES, ALLOWED_IMAGE_TYPES, validateFile, saveFile, getUploadDir
  </done>
</task>

</tasks>

<verification>
- [ ] backend/src/utils/slug.ts exists with generateSlug and createUniqueSlug
- [ ] backend/src/utils/file-upload.ts exists with all constants and functions
- [ ] TypeScript compiles: `cd backend && npx tsc --noEmit`
- [ ] No external dependencies added (uses native crypto, fs/promises, path)
</verification>

<success_criteria>
- Slug generation handles special characters correctly
- Unique slug generation can query both courses and researchReports tables
- File validation returns result objects (not exceptions)
- File saving uses UUID filenames for security
</success_criteria>

<output>
After completion, create `.planning/phases/03-content-api/03-02-SUMMARY.md`
</output>
