---
phase: 04-payment-integration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/promo.service.ts
  - backend/src/services/referral.service.ts
autonomous: true

must_haves:
  truths:
    - "Promo codes can be validated with expiry and usage checks"
    - "Promo code usage is incremented atomically on application"
    - "Referral codes are generated for members"
    - "Referral rewards are tracked when referred users pay"
  artifacts:
    - path: "backend/src/services/promo.service.ts"
      provides: "Promo code validation and application"
      exports: ["validatePromoCode", "applyPromoCode", "calculateDiscountedAmount"]
      min_lines: 60
    - path: "backend/src/services/referral.service.ts"
      provides: "Referral code generation and reward tracking"
      exports: ["generateReferralCode", "validateReferralCode", "recordReferralReward"]
      min_lines: 80
  key_links:
    - from: "backend/src/services/promo.service.ts"
      to: "promo_codes table"
      via: "Drizzle ORM queries"
      pattern: "promoCodes"
    - from: "backend/src/services/referral.service.ts"
      to: "referrals table"
      via: "Drizzle ORM queries and transactions"
      pattern: "referrals"
---

<objective>
Create promo code validation and referral tracking services

Purpose: Handle discount logic for checkout and reward tracking for referral program. These services are used by payment routes and webhook handler.
Output: Promo and referral services with validation, application, and reward logic
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-integration/04-RESEARCH.md

Existing patterns to follow:
@backend/src/services/email.service.ts (result object pattern)
@backend/src/services/token.service.ts (crypto utilities pattern)
@backend/src/db/index.ts (database transaction pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create promo code service</name>
  <files>backend/src/services/promo.service.ts</files>
  <action>
Create `backend/src/services/promo.service.ts`:

```typescript
import { and, eq, gt, or, isNull, sql } from 'drizzle-orm'
import { db } from '../db/index.js'
import { promoCodes } from '../db/schema/index.js'

// Result types following existing pattern
interface PromoValidationResult {
  success: boolean
  promoCodeId?: number
  discountPercent?: number
  error?: string
}

/**
 * Validate a promo code
 * Checks: exists, active, not expired, within usage limits
 */
export async function validatePromoCode(code: string): Promise<PromoValidationResult> {
  const normalizedCode = code.toUpperCase().trim()

  const promo = await db.query.promoCodes.findFirst({
    where: and(
      eq(promoCodes.code, normalizedCode),
      eq(promoCodes.isActive, true),
      // Not expired: expiresAt is null OR expiresAt > now
      or(
        isNull(promoCodes.expiresAt),
        gt(promoCodes.expiresAt, new Date())
      ),
      // Not before valid period: validFrom is null OR validFrom <= now
      or(
        isNull(promoCodes.validFrom),
        sql`${promoCodes.validFrom} <= NOW()`
      ),
      // Within usage limits: maxUses is null OR currentUses < maxUses
      or(
        isNull(promoCodes.maxUses),
        sql`${promoCodes.currentUses} < ${promoCodes.maxUses}`
      )
    ),
  })

  if (!promo) {
    return { success: false, error: 'Invalid or expired promo code' }
  }

  return {
    success: true,
    promoCodeId: promo.id,
    discountPercent: promo.discountPercent
  }
}

/**
 * Apply promo code (increment usage counter)
 * Call this AFTER successful payment confirmation
 * Uses atomic increment to prevent race conditions
 */
export async function applyPromoCode(promoCodeId: number): Promise<{ success: boolean; error?: string }> {
  try {
    await db.update(promoCodes)
      .set({
        currentUses: sql`${promoCodes.currentUses} + 1`,
        updatedAt: new Date()
      })
      .where(eq(promoCodes.id, promoCodeId))

    return { success: true }
  } catch (err) {
    console.error('Failed to apply promo code:', err)
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to apply promo code'
    }
  }
}

/**
 * Calculate discounted amount
 * @param originalAmount - Original price in IDR
 * @param discountPercent - Discount percentage (0-100)
 * @returns Discounted amount (rounded to nearest integer)
 */
export function calculateDiscountedAmount(
  originalAmount: number,
  discountPercent: number
): number {
  if (discountPercent < 0 || discountPercent > 100) {
    return originalAmount
  }
  const discount = Math.round(originalAmount * (discountPercent / 100))
  return originalAmount - discount
}

/**
 * Get promo code by ID
 * Used for displaying applied discount in UI
 */
export async function getPromoCode(id: number) {
  return db.query.promoCodes.findFirst({
    where: eq(promoCodes.id, id),
  })
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no errors
  </verify>
  <done>
promo.service.ts exports validatePromoCode, applyPromoCode, calculateDiscountedAmount, getPromoCode with proper validation logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Create referral service</name>
  <files>backend/src/services/referral.service.ts</files>
  <action>
Create `backend/src/services/referral.service.ts`:

```typescript
import { eq, sql } from 'drizzle-orm'
import { customAlphabet } from 'nanoid'
import { db } from '../db/index.js'
import { referrals, referralUsages } from '../db/schema/index.js'
import { env } from '../config/env.js'

// Alphabet without ambiguous characters (0, O, I, l)
const generateCode = customAlphabet('ABCDEFGHJKLMNPQRSTUVWXYZ23456789', 8)

// Result types
interface ReferralResult {
  success: boolean
  referralId?: number
  code?: string
  error?: string
}

interface ReferralValidationResult {
  success: boolean
  referralId?: number
  referrerId?: number
  error?: string
}

/**
 * Generate a unique referral code for a user
 * Called when user becomes a member (after first subscription payment)
 */
export async function generateReferralCode(userId: number): Promise<ReferralResult> {
  // Check if user already has a referral code
  const existing = await db.query.referrals.findFirst({
    where: eq(referrals.userId, userId),
  })

  if (existing) {
    return {
      success: true,
      referralId: existing.id,
      code: existing.code
    }
  }

  // Generate unique code with retry logic
  let attempts = 0
  const maxAttempts = 5

  while (attempts < maxAttempts) {
    const code = generateCode()

    try {
      const [referral] = await db.insert(referrals)
        .values({
          userId,
          code,
        })
        .returning()

      return {
        success: true,
        referralId: referral.id,
        code: referral.code
      }
    } catch (err: unknown) {
      // Check for unique constraint violation (code collision)
      if (err && typeof err === 'object' && 'code' in err && err.code === '23505') {
        attempts++
        continue
      }
      throw err
    }
  }

  return {
    success: false,
    error: 'Failed to generate unique referral code after multiple attempts'
  }
}

/**
 * Validate a referral code
 * Returns referral ID and referrer user ID if valid
 */
export async function validateReferralCode(code: string): Promise<ReferralValidationResult> {
  const normalizedCode = code.toUpperCase().trim()

  const referral = await db.query.referrals.findFirst({
    where: eq(referrals.code, normalizedCode),
  })

  if (!referral) {
    return { success: false, error: 'Invalid referral code' }
  }

  return {
    success: true,
    referralId: referral.id,
    referrerId: referral.userId
  }
}

/**
 * Record referral reward when referred user completes payment
 * Call this from webhook handler ONLY on successful settlement
 *
 * Uses transaction to ensure atomicity:
 * 1. Insert usage record
 * 2. Update referral stats
 */
export async function recordReferralReward(
  referralId: number,
  newUserId: number,
  paymentId: number
): Promise<{ success: boolean; error?: string }> {
  const rewardAmount = env.REFERRAL_REWARD_AMOUNT

  try {
    await db.transaction(async (tx) => {
      // Insert usage record
      await tx.insert(referralUsages).values({
        referralId,
        newUserId,
        paymentId,
        rewardAmount,
      })

      // Update referral stats (atomic increment)
      await tx.update(referrals)
        .set({
          totalUses: sql`${referrals.totalUses} + 1`,
          rewardsEarned: sql`${referrals.rewardsEarned} + ${rewardAmount}`,
        })
        .where(eq(referrals.id, referralId))
    })

    return { success: true }
  } catch (err) {
    console.error('Failed to record referral reward:', err)
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to record referral reward'
    }
  }
}

/**
 * Get referral stats for a user
 * Used in member dashboard to show referral performance
 */
export async function getReferralStats(userId: number) {
  const referral = await db.query.referrals.findFirst({
    where: eq(referrals.userId, userId),
    with: {
      usages: {
        columns: {
          id: true,
          rewardAmount: true,
          createdAt: true,
        },
      },
    },
  })

  if (!referral) {
    return null
  }

  return {
    code: referral.code,
    totalUses: referral.totalUses,
    rewardsEarned: referral.rewardsEarned,
    recentUsages: referral.usages.slice(0, 10), // Last 10 usages
  }
}

/**
 * Get referral by code (for display purposes)
 */
export async function getReferralByCode(code: string) {
  return db.query.referrals.findFirst({
    where: eq(referrals.code, code.toUpperCase().trim()),
  })
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no errors
  </verify>
  <done>
referral.service.ts exports generateReferralCode, validateReferralCode, recordReferralReward, getReferralStats, getReferralByCode with atomic reward tracking
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && npx tsc --noEmit` passes
2. Promo service exports: validatePromoCode, applyPromoCode, calculateDiscountedAmount, getPromoCode
3. Referral service exports: generateReferralCode, validateReferralCode, recordReferralReward, getReferralStats, getReferralByCode
4. Atomic operations: Both services use SQL atomic increments for counters
5. Transaction usage: recordReferralReward wraps insert + update in transaction
</verification>

<success_criteria>
- Promo code validation checks active status, expiry, and usage limits
- Promo code application uses atomic SQL increment
- Referral code generation uses nanoid with collision retry logic
- Referral reward tracking uses database transaction for consistency
- Result object pattern consistent with other services
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-integration/04-03-SUMMARY.md`
</output>
