---
phase: 04-payment-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/config/env.ts
  - backend/.env.example
  - backend/src/services/payment.service.ts
  - backend/package.json
autonomous: true

user_setup:
  - service: midtrans
    why: "Payment processing for Indonesian market"
    env_vars:
      - name: MIDTRANS_SERVER_KEY
        source: "Midtrans Dashboard -> Settings -> Access Keys -> Server Key"
      - name: MIDTRANS_CLIENT_KEY
        source: "Midtrans Dashboard -> Settings -> Access Keys -> Client Key"
    dashboard_config:
      - task: "Create Midtrans account"
        location: "https://dashboard.midtrans.com"
      - task: "Enable Snap payment method"
        location: "Midtrans Dashboard -> Settings -> Payment Methods"
      - task: "Configure webhook URL (after deployment)"
        location: "Midtrans Dashboard -> Settings -> Notification URL"

must_haves:
  truths:
    - "Midtrans Snap token can be created for subscription payments"
    - "Midtrans Snap token can be created for workshop payments"
    - "Environment validates Midtrans API keys at startup"
  artifacts:
    - path: "backend/src/services/payment.service.ts"
      provides: "Midtrans Snap integration for payment creation"
      exports: ["createSubscriptionPayment", "createWorkshopPayment"]
      min_lines: 80
    - path: "backend/src/config/env.ts"
      provides: "Midtrans environment configuration"
      contains: "MIDTRANS_SERVER_KEY"
  key_links:
    - from: "backend/src/services/payment.service.ts"
      to: "midtrans-client"
      via: "Snap API client"
      pattern: "midtransClient\\.Snap"
---

<objective>
Create payment service with Midtrans Snap integration for generating payment tokens

Purpose: Enable backend to create Midtrans Snap transactions that frontend can use to display payment UI. This is the core payment initiation capability.
Output: Payment service with subscription and workshop payment methods
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payment-integration/04-RESEARCH.md

Existing patterns to follow:
@backend/src/config/env.ts (environment validation pattern)
@backend/src/services/email.service.ts (result object pattern)
@backend/src/services/auth.service.ts (service module pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend environment config for Midtrans</name>
  <files>
    backend/src/config/env.ts
    backend/.env.example
  </files>
  <action>
Add Midtrans configuration to environment validation:

In `backend/src/config/env.ts`, add to the envSchema:
```typescript
// Midtrans Payment Gateway
MIDTRANS_SERVER_KEY: z.string().min(10, 'MIDTRANS_SERVER_KEY is required'),
MIDTRANS_CLIENT_KEY: z.string().min(10, 'MIDTRANS_CLIENT_KEY is required'),
MIDTRANS_IS_PRODUCTION: z.string().default('false').transform((val) => val === 'true'),

// Referral System
REFERRAL_REWARD_AMOUNT: z.string().default('50000').transform(Number), // IDR 50,000 default
```

In `backend/.env.example`, add:
```
# Midtrans Payment Gateway
# Get keys from: https://dashboard.midtrans.com -> Settings -> Access Keys
MIDTRANS_SERVER_KEY=your_server_key
MIDTRANS_CLIENT_KEY=your_client_key
MIDTRANS_IS_PRODUCTION=false

# Referral System
# Reward amount in IDR when referred user completes payment
REFERRAL_REWARD_AMOUNT=50000
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
  </verify>
  <done>
env.ts validates Midtrans keys, .env.example documents all payment-related environment variables
  </done>
</task>

<task type="auto">
  <name>Task 2: Install midtrans-client and create payment service</name>
  <files>
    backend/package.json
    backend/src/services/payment.service.ts
  </files>
  <action>
1. Install midtrans-client and nanoid:
   ```bash
   cd backend && npm install midtrans-client nanoid
   ```

2. Create `backend/src/services/payment.service.ts`:
```typescript
import midtransClient from 'midtrans-client'
import { nanoid } from 'nanoid'
import { env } from '../config/env.js'

// Initialize Midtrans Snap client
const snap = new midtransClient.Snap({
  isProduction: env.MIDTRANS_IS_PRODUCTION,
  serverKey: env.MIDTRANS_SERVER_KEY,
  clientKey: env.MIDTRANS_CLIENT_KEY,
})

// Result types following existing pattern (from email.service.ts)
interface PaymentResult {
  success: boolean
  token?: string
  redirectUrl?: string
  orderId?: string
  error?: string
}

interface PaymentParams {
  userId: number
  userEmail: string
  userName: string
  amount: number // In IDR
  promoCodeId?: number
  referralId?: number
}

/**
 * Generate unique order ID with timestamp and random suffix
 * Format: sub-{userId}-{timestamp}-{nanoid} for subscriptions
 *         ws-{userId}-{workshopId}-{timestamp}-{nanoid} for workshops
 */
function generateOrderId(prefix: string, userId: number, itemId?: number): string {
  const timestamp = Date.now()
  const suffix = nanoid(6)
  if (itemId !== undefined) {
    return `${prefix}-${userId}-${itemId}-${timestamp}-${suffix}`
  }
  return `${prefix}-${userId}-${timestamp}-${suffix}`
}

/**
 * Extract userId from order ID
 * Used in webhook handler to identify the user
 */
export function extractUserIdFromOrderId(orderId: string): number {
  const parts = orderId.split('-')
  // Format: prefix-userId-... or prefix-userId-itemId-...
  return parseInt(parts[1], 10)
}

/**
 * Extract workshop ID from order ID (if present)
 */
export function extractWorkshopIdFromOrderId(orderId: string): number | null {
  const parts = orderId.split('-')
  // Workshop format: ws-userId-workshopId-timestamp-suffix
  if (parts[0] === 'ws' && parts.length >= 4) {
    return parseInt(parts[2], 10)
  }
  return null
}

/**
 * Create Midtrans Snap transaction for annual subscription
 * Returns token for frontend Snap.js integration
 */
export async function createSubscriptionPayment(
  params: PaymentParams
): Promise<PaymentResult> {
  const { userId, userEmail, userName, amount, promoCodeId, referralId } = params

  const orderId = generateOrderId('sub', userId)

  try {
    const parameter = {
      transaction_details: {
        order_id: orderId,
        gross_amount: amount,
      },
      customer_details: {
        first_name: userName,
        email: userEmail,
      },
      item_details: [{
        id: 'annual-subscription',
        price: amount,
        quantity: 1,
        name: 'StockUs Annual Membership',
      }],
      // Store metadata for webhook processing
      custom_field1: promoCodeId?.toString() || '',
      custom_field2: referralId?.toString() || '',
    }

    const transaction = await snap.createTransaction(parameter)

    return {
      success: true,
      token: transaction.token,
      redirectUrl: transaction.redirect_url,
      orderId,
    }
  } catch (err) {
    console.error('Midtrans subscription payment error:', err)
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to create payment'
    }
  }
}

/**
 * Create Midtrans Snap transaction for workshop purchase
 */
export async function createWorkshopPayment(
  params: PaymentParams & { workshopId: number; workshopName: string }
): Promise<PaymentResult> {
  const { userId, userEmail, userName, amount, workshopId, workshopName, promoCodeId, referralId } = params

  const orderId = generateOrderId('ws', userId, workshopId)

  try {
    const parameter = {
      transaction_details: {
        order_id: orderId,
        gross_amount: amount,
      },
      customer_details: {
        first_name: userName,
        email: userEmail,
      },
      item_details: [{
        id: `workshop-${workshopId}`,
        price: amount,
        quantity: 1,
        name: workshopName,
      }],
      // Store metadata for webhook processing
      custom_field1: promoCodeId?.toString() || '',
      custom_field2: referralId?.toString() || '',
    }

    const transaction = await snap.createTransaction(parameter)

    return {
      success: true,
      token: transaction.token,
      redirectUrl: transaction.redirect_url,
      orderId,
    }
  } catch (err) {
    console.error('Midtrans workshop payment error:', err)
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to create payment'
    }
  }
}

/**
 * Check transaction status via Midtrans API
 * Use as fallback when webhook doesn't arrive
 */
export async function checkTransactionStatus(orderId: string): Promise<PaymentResult & { status?: string }> {
  try {
    const response = await snap.transaction.status(orderId)

    return {
      success: true,
      orderId,
      status: response.transaction_status,
    }
  } catch (err) {
    console.error('Midtrans status check error:', err)
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to check status'
    }
  }
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no errors
2. Check that midtrans-client and nanoid are in package.json dependencies
  </verify>
  <done>
payment.service.ts exports createSubscriptionPayment, createWorkshopPayment, checkTransactionStatus, and helper functions for order ID parsing
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd backend && npx tsc --noEmit` passes
2. Dependencies: midtrans-client and nanoid in package.json
3. Service exports: createSubscriptionPayment, createWorkshopPayment, checkTransactionStatus, extractUserIdFromOrderId, extractWorkshopIdFromOrderId
4. Environment: MIDTRANS_SERVER_KEY, MIDTRANS_CLIENT_KEY, MIDTRANS_IS_PRODUCTION, REFERRAL_REWARD_AMOUNT validated
</verification>

<success_criteria>
- Midtrans Snap client initialized with environment config
- Payment creation returns token for frontend integration
- Order ID generation includes uniqueness (timestamp + nanoid)
- Helper functions for webhook to extract user/workshop IDs
- Result object pattern consistent with email.service.ts
</success_criteria>

<output>
After completion, create `.planning/phases/04-payment-integration/04-02-SUMMARY.md`
</output>
