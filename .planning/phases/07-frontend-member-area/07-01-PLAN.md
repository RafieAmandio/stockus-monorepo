---
phase: 07-frontend-member-area
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/auth/dal.ts
  - frontend/src/lib/auth/session.ts
  - frontend/src/lib/api-client.ts
  - frontend/src/middleware.ts
  - frontend/src/types/auth.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated API calls forward cookies to backend"
    - "Protected routes redirect unauthenticated users to login"
    - "Session verification uses jose for JWT validation"
  artifacts:
    - path: "frontend/src/lib/auth/dal.ts"
      provides: "Data Access Layer for server-side auth verification"
      exports: ["verifySession", "requireAuth", "getUser"]
    - path: "frontend/src/lib/api-client.ts"
      provides: "Enhanced API client with cookie forwarding"
      exports: ["fetchAPI", "clientFetchAPI"]
    - path: "frontend/src/middleware.ts"
      provides: "Route protection middleware"
      contains: "matcher.*dashboard|courses|research|downloads|cohorts|profile"
  key_links:
    - from: "frontend/src/lib/auth/dal.ts"
      to: "jose library"
      via: "jwtVerify with HS256"
      pattern: "jwtVerify.*JWT_SECRET.*HS256"
    - from: "frontend/src/lib/api-client.ts"
      to: "backend API"
      via: "cookie forwarding"
      pattern: "Cookie.*access_token"
---

<objective>
Create authentication infrastructure for member area: Data Access Layer (DAL) for server-side session verification, enhanced API client with cookie forwarding, and Next.js middleware for route protection.

Purpose: Establishes defense-in-depth security - middleware for optimistic redirects, DAL for secure data access, API client for authenticated requests to backend.
Output: Auth infrastructure that all member pages will use.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-frontend-member-area/07-RESEARCH.md

# Existing frontend infrastructure
@frontend/src/lib/api.ts (existing fetchAPI without auth)
@frontend/src/types/index.ts (existing types)

# Backend auth reference
@backend/src/middleware/auth.ts (JWT structure, tier levels)
@backend/src/routes/auth.ts (cookie config, /me endpoint)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install auth dependencies and create auth types</name>
  <files>
    frontend/package.json
    frontend/src/types/auth.ts
  </files>
  <action>
Install jose for JWT verification in Next.js middleware/server:
```bash
cd frontend && npm install jose
```

Create auth types at `frontend/src/types/auth.ts`:
```typescript
// Session payload from JWT (mirrors backend JwtPayload)
export interface SessionPayload {
  sub: number // userId
  tier: 'free' | 'member'
  exp: number
  iat: number
}

// User from /auth/me endpoint
export interface User {
  id: number
  email: string
  name: string
  tier: 'free' | 'member'
  isVerified: boolean
  createdAt: string
}

// Auth state for client components
export interface AuthState {
  user: User | null
  isLoading: boolean
  isAuthenticated: boolean
}
```
  </action>
  <verify>
Run `npm ls jose` in frontend directory - should show jose installed.
Check `frontend/src/types/auth.ts` exists with SessionPayload, User, AuthState exports.
  </verify>
  <done>jose installed, auth types defined with SessionPayload matching backend JWT structure.</done>
</task>

<task type="auto">
  <name>Task 2: Create DAL and enhanced API client</name>
  <files>
    frontend/src/lib/auth/dal.ts
    frontend/src/lib/auth/session.ts
    frontend/src/lib/api-client.ts
  </files>
  <action>
Create `frontend/src/lib/auth/` directory.

Create `frontend/src/lib/auth/session.ts` (server-only constants):
```typescript
import 'server-only'

export const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'fallback-secret-for-development'
)

export const AUTH_COOKIE_NAME = 'access_token'
export const REFRESH_COOKIE_NAME = 'refresh_token'
```

Create `frontend/src/lib/auth/dal.ts` (Data Access Layer):
```typescript
import 'server-only'
import { cache } from 'react'
import { cookies } from 'next/headers'
import { jwtVerify } from 'jose'
import { redirect } from 'next/navigation'
import { JWT_SECRET, AUTH_COOKIE_NAME } from './session'
import type { SessionPayload, User } from '@/types/auth'

// Cache verification result for request lifecycle
export const verifySession = cache(async (): Promise<SessionPayload | null> => {
  const cookieStore = await cookies()
  const token = cookieStore.get(AUTH_COOKIE_NAME)?.value

  if (!token) {
    return null
  }

  try {
    const { payload } = await jwtVerify(token, JWT_SECRET, {
      algorithms: ['HS256'],
    })
    return payload as unknown as SessionPayload
  } catch {
    return null
  }
})

// Require auth - redirects to login if not authenticated
export const requireAuth = cache(async () => {
  const session = await verifySession()
  if (!session) {
    redirect('/login')
  }
  return session
})

// Require member tier - redirects to pricing if free user
export const requireMember = cache(async () => {
  const session = await requireAuth()
  if (session.tier !== 'member') {
    redirect('/pricing')
  }
  return session
})

// Get full user info from backend
export const getUser = cache(async (): Promise<User | null> => {
  const session = await verifySession()
  if (!session) {
    return null
  }

  const cookieStore = await cookies()
  const token = cookieStore.get(AUTH_COOKIE_NAME)?.value

  try {
    const res = await fetch(`${process.env.API_URL || 'http://localhost:3000'}/auth/me`, {
      headers: {
        Cookie: `access_token=${token}`,
      },
      cache: 'no-store',
    })

    if (!res.ok) {
      return null
    }

    const data = await res.json()
    return data.user
  } catch {
    return null
  }
})
```

Create `frontend/src/lib/api-client.ts` (enhanced API client with auth):
```typescript
import { cookies } from 'next/headers'

const API_URL = process.env.API_URL || 'http://localhost:3000'
const PUBLIC_API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000'

/**
 * Server-side API client with cookie forwarding
 * Use in Server Components and Route Handlers
 */
export async function fetchAPI<T>(
  endpoint: string,
  options: RequestInit & { revalidate?: number } = {}
): Promise<T> {
  const { revalidate, ...fetchOptions } = options

  // Forward authentication cookies to backend
  const cookieStore = await cookies()
  const accessToken = cookieStore.get('access_token')?.value
  const refreshToken = cookieStore.get('refresh_token')?.value

  const cookieHeader = [
    accessToken ? `access_token=${accessToken}` : '',
    refreshToken ? `refresh_token=${refreshToken}` : '',
  ].filter(Boolean).join('; ')

  const res = await fetch(`${API_URL}${endpoint}`, {
    ...fetchOptions,
    headers: {
      'Content-Type': 'application/json',
      ...fetchOptions.headers,
      ...(cookieHeader ? { Cookie: cookieHeader } : {}),
    },
    next: revalidate !== undefined ? { revalidate } : undefined,
  })

  if (!res.ok) {
    const error = new Error(`API Error: ${res.status} ${res.statusText}`)
    ;(error as any).status = res.status
    throw error
  }

  return res.json()
}

/**
 * Client-side API client
 * Use in Client Components with 'use client'
 */
export async function clientFetchAPI<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const res = await fetch(`${PUBLIC_API_URL}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
    credentials: 'include', // Send cookies automatically
  })

  if (!res.ok) {
    const error = new Error(`API Error: ${res.status} ${res.statusText}`)
    ;(error as any).status = res.status
    throw error
  }

  return res.json()
}
```
  </action>
  <verify>
Check files exist:
- `frontend/src/lib/auth/dal.ts` with verifySession, requireAuth, requireMember, getUser exports
- `frontend/src/lib/auth/session.ts` with JWT_SECRET constant
- `frontend/src/lib/api-client.ts` with fetchAPI, clientFetchAPI exports

TypeScript should compile: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>DAL pattern implemented with cached session verification, API client forwards cookies to backend.</done>
</task>

<task type="auto">
  <name>Task 3: Create middleware for route protection</name>
  <files>
    frontend/src/middleware.ts
    frontend/.env.local
  </files>
  <action>
Create `frontend/src/middleware.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { jwtVerify } from 'jose'

const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'fallback-secret-for-development'
)

// Routes that require authentication
const PROTECTED_ROUTES = [
  '/dashboard',
  '/courses',
  '/research',
  '/downloads',
  '/cohorts',
  '/profile',
]

// Routes that authenticated users shouldn't access
const AUTH_ROUTES = ['/login', '/signup']

export async function middleware(req: NextRequest) {
  const token = req.cookies.get('access_token')?.value
  const pathname = req.nextUrl.pathname

  // Check if route is protected
  const isProtectedRoute = PROTECTED_ROUTES.some(route =>
    pathname.startsWith(route)
  )
  const isAuthRoute = AUTH_ROUTES.some(route =>
    pathname.startsWith(route)
  )

  // Verify token if present
  let isValidToken = false
  if (token) {
    try {
      await jwtVerify(token, JWT_SECRET, { algorithms: ['HS256'] })
      isValidToken = true
    } catch {
      // Token invalid or expired
    }
  }

  // Redirect unauthenticated users away from protected routes
  if (isProtectedRoute && !isValidToken) {
    const loginUrl = new URL('/login', req.url)
    loginUrl.searchParams.set('redirect', pathname)
    return NextResponse.redirect(loginUrl)
  }

  // Redirect authenticated users away from auth routes
  if (isAuthRoute && isValidToken) {
    return NextResponse.redirect(new URL('/dashboard', req.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico, images, etc
     */
    '/((?!api|_next/static|_next/image|favicon.ico|.*\\.png$|.*\\.svg$).*)',
  ],
}
```

Update `frontend/.env.local` to include JWT_SECRET (must match backend):
```
API_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3000
JWT_SECRET=your-jwt-secret-must-match-backend
```

Note: The JWT_SECRET should match the backend's JWT_SECRET for token verification.
  </action>
  <verify>
Check `frontend/src/middleware.ts` exists with PROTECTED_ROUTES array including dashboard, courses, research, downloads, cohorts, profile.
Check matcher config excludes api and static files.
Build should succeed: `cd frontend && npm run build`
  </verify>
  <done>Middleware protects member routes, redirects unauthenticated users to login with redirect param.</done>
</task>

</tasks>

<verification>
Run all verification commands:

```bash
cd frontend

# Check dependencies installed
npm ls jose

# Check TypeScript compiles
npx tsc --noEmit

# Check build succeeds
npm run build

# Verify file structure
ls -la src/lib/auth/
ls -la src/middleware.ts
```

All should pass without errors.
</verification>

<success_criteria>
1. jose library installed in frontend
2. TypeScript compiles without errors
3. Build succeeds
4. DAL exports verifySession, requireAuth, requireMember, getUser
5. API client exports fetchAPI (server), clientFetchAPI (client)
6. Middleware protects all member routes
</success_criteria>

<output>
After completion, create `.planning/phases/07-frontend-member-area/07-01-SUMMARY.md`
</output>
