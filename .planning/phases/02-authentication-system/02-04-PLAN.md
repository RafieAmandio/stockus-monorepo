---
phase: 02-authentication-system
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - backend/src/routes/auth.ts
  - backend/src/routes/index.ts
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password"
    - "User can login with email and password"
    - "JWT tokens set in HTTP-only cookies on login"
    - "User can logout and cookies are cleared"
    - "Refresh token rotation works on /auth/refresh"
  artifacts:
    - path: "backend/src/routes/auth.ts"
      provides: "Authentication endpoints"
      exports: ["auth"]
    - path: "backend/src/routes/index.ts"
      provides: "Route mounting"
      contains: "auth"
  key_links:
    - from: "backend/src/routes/auth.ts"
      to: "backend/src/services/auth.service.ts"
      via: "password hashing and JWT generation"
      pattern: "hashPassword|generateAccessToken"
    - from: "backend/src/routes/auth.ts"
      to: "backend/src/db/schema"
      via: "database queries"
      pattern: "db\\.insert.*users|db\\.query\\.users"
---

<objective>
Create core authentication routes: signup, login, logout, and token refresh endpoints.

Purpose: Enable users to create accounts, authenticate, and maintain sessions via JWT in HTTP-only cookies.
Output: Complete auth.ts route file with POST /signup, POST /login, POST /logout, POST /refresh endpoints.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-system/02-RESEARCH.md
@.planning/phases/02-authentication-system/02-01-SUMMARY.md
@.planning/phases/02-authentication-system/02-02-SUMMARY.md
@.planning/phases/02-authentication-system/02-03-SUMMARY.md

# Existing patterns
@backend/src/routes/health.ts
@backend/src/routes/index.ts
@backend/src/app.ts
@backend/src/db/schema/users.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth routes with signup and login</name>
  <files>backend/src/routes/auth.ts</files>
  <action>
Create auth.ts route file:

```typescript
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { z } from 'zod'
import { setCookie, getCookie, deleteCookie } from 'hono/cookie'
import { eq, and, gt } from 'drizzle-orm'

import { db } from '../db/index.js'
import { users } from '../db/schema/users.js'
import { sessions } from '../db/schema/sessions.js'
import { tokens } from '../db/schema/tokens.js'
import { env } from '../config/env.js'
import {
  hashPassword,
  verifyPassword,
  generateAccessToken,
  generateRefreshToken,
} from '../services/auth.service.js'
import { hashToken, hoursFromNow } from '../services/token.service.js'
import { sendVerificationEmail } from '../services/email.service.js'
import { authMiddleware, AuthEnv } from '../middleware/auth.js'
import { generateToken } from '../services/token.service.js'

// Validation schemas
const signupSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
})

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string(),
})

// Cookie configuration
const COOKIE_CONFIG = {
  httpOnly: true,
  secure: env.NODE_ENV === 'production',
  sameSite: 'Strict' as const,
  path: '/',
}

export const auth = new Hono<AuthEnv>()

/**
 * POST /auth/signup
 * Create new user account, send verification email
 */
auth.post('/signup', zValidator('json', signupSchema), async (c) => {
  const { email, password, name } = c.req.valid('json')

  // Check if email already exists
  const existingUser = await db.query.users.findFirst({
    where: eq(users.email, email.toLowerCase()),
  })

  if (existingUser) {
    return c.json({ error: 'Email already registered' }, 409)
  }

  // Hash password
  const passwordHash = await hashPassword(password)

  // Create user
  const [user] = await db.insert(users).values({
    email: email.toLowerCase(),
    name,
    passwordHash,
    isVerified: false,
    tier: 'free',
  }).returning({ id: users.id, email: users.email, name: users.name })

  // Generate verification token
  const verificationToken = generateToken()
  const tokenHash = hashToken(verificationToken)

  await db.insert(tokens).values({
    userId: user.id,
    type: 'email_verification',
    tokenHash,
    expiresAt: hoursFromNow(24), // 24 hour expiry
  })

  // Send verification email (don't block on failure)
  sendVerificationEmail(user.email, verificationToken, user.name).catch(err => {
    console.error('Failed to send verification email:', err)
  })

  return c.json({
    message: 'Account created. Please check your email to verify.',
    user: { id: user.id, email: user.email, name: user.name }
  }, 201)
})

/**
 * POST /auth/login
 * Authenticate user, issue JWT tokens in cookies
 */
auth.post('/login', zValidator('json', loginSchema), async (c) => {
  const { email, password } = c.req.valid('json')

  // Find user
  const user = await db.query.users.findFirst({
    where: eq(users.email, email.toLowerCase()),
  })

  if (!user || !user.passwordHash) {
    return c.json({ error: 'Invalid credentials' }, 401)
  }

  // Verify password
  const isValid = await verifyPassword(password, user.passwordHash)
  if (!isValid) {
    return c.json({ error: 'Invalid credentials' }, 401)
  }

  // Check email verification
  if (!user.isVerified) {
    return c.json({ error: 'Please verify your email before logging in' }, 403)
  }

  // Generate tokens
  const accessToken = await generateAccessToken(user.id, user.tier)
  const { token: refreshToken, hash: refreshHash, expiresAt } = generateRefreshToken()

  // Store refresh token in database
  await db.insert(sessions).values({
    userId: user.id,
    tokenHash: refreshHash,
    expiresAt,
  })

  // Set cookies
  setCookie(c, 'access_token', accessToken, {
    ...COOKIE_CONFIG,
    maxAge: env.JWT_ACCESS_EXPIRES_MINUTES * 60,
  })

  setCookie(c, 'refresh_token', refreshToken, {
    ...COOKIE_CONFIG,
    maxAge: env.JWT_REFRESH_EXPIRES_DAYS * 24 * 60 * 60,
    path: '/auth/refresh', // Limit refresh token scope
  })

  return c.json({
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      tier: user.tier,
    }
  })
})

/**
 * POST /auth/logout
 * Clear tokens and invalidate session
 */
auth.post('/logout', authMiddleware, async (c) => {
  const userId = c.get('userId')
  const refreshToken = getCookie(c, 'refresh_token')

  // Delete session from database if refresh token present
  if (refreshToken) {
    const tokenHash = hashToken(refreshToken)
    await db.delete(sessions).where(
      and(
        eq(sessions.userId, userId),
        eq(sessions.tokenHash, tokenHash)
      )
    )
  }

  // Clear cookies
  deleteCookie(c, 'access_token', { path: '/' })
  deleteCookie(c, 'refresh_token', { path: '/auth/refresh' })

  return c.json({ message: 'Logged out successfully' })
})

/**
 * POST /auth/refresh
 * Rotate refresh token and issue new access token
 */
auth.post('/refresh', async (c) => {
  const refreshToken = getCookie(c, 'refresh_token')

  if (!refreshToken) {
    return c.json({ error: 'Refresh token required' }, 401)
  }

  const tokenHash = hashToken(refreshToken)

  // Find and validate session
  const session = await db.query.sessions.findFirst({
    where: and(
      eq(sessions.tokenHash, tokenHash),
      gt(sessions.expiresAt, new Date())
    ),
  })

  if (!session) {
    // Clear potentially invalid cookies
    deleteCookie(c, 'access_token', { path: '/' })
    deleteCookie(c, 'refresh_token', { path: '/auth/refresh' })
    return c.json({ error: 'Invalid or expired refresh token' }, 401)
  }

  // Get user for new token
  const user = await db.query.users.findFirst({
    where: eq(users.id, session.userId),
  })

  if (!user) {
    return c.json({ error: 'User not found' }, 401)
  }

  // Delete old session (rotation)
  await db.delete(sessions).where(eq(sessions.id, session.id))

  // Generate new tokens
  const newAccessToken = await generateAccessToken(user.id, user.tier)
  const { token: newRefreshToken, hash: newRefreshHash, expiresAt } = generateRefreshToken()

  // Store new refresh token
  await db.insert(sessions).values({
    userId: user.id,
    tokenHash: newRefreshHash,
    expiresAt,
  })

  // Set new cookies
  setCookie(c, 'access_token', newAccessToken, {
    ...COOKIE_CONFIG,
    maxAge: env.JWT_ACCESS_EXPIRES_MINUTES * 60,
  })

  setCookie(c, 'refresh_token', newRefreshToken, {
    ...COOKIE_CONFIG,
    maxAge: env.JWT_REFRESH_EXPIRES_DAYS * 24 * 60 * 60,
    path: '/auth/refresh',
  })

  return c.json({ message: 'Tokens refreshed' })
})

/**
 * GET /auth/me
 * Get current user info (requires auth)
 */
auth.get('/me', authMiddleware, async (c) => {
  const userId = c.get('userId')

  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: {
      id: true,
      email: true,
      name: true,
      tier: true,
      isVerified: true,
      createdAt: true,
    }
  })

  if (!user) {
    return c.json({ error: 'User not found' }, 404)
  }

  return c.json({ user })
})
```

Key points:
- Email normalized to lowercase
- Verification required before login
- Refresh token scoped to /auth/refresh path only
- Token rotation on refresh (delete old, create new)
- Zod validation on inputs
  </action>
  <verify>`cd backend && npx tsc --noEmit` compiles without errors</verify>
  <done>auth.ts created with signup, login, logout, refresh, me endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Install zod-validator and mount auth routes</name>
  <files>backend/src/routes/index.ts, backend/package.json</files>
  <action>
1. Install @hono/zod-validator: `cd backend && npm install @hono/zod-validator`

2. Update routes/index.ts to mount auth routes:

```typescript
import { Hono } from 'hono'
import { health } from './health.js'
import { auth } from './auth.js'

const routes = new Hono()

// Health check routes
routes.route('/health', health)

// Authentication routes
routes.route('/auth', auth)

export { routes }
```
  </action>
  <verify>
1. `cd backend && npm ls @hono/zod-validator` shows package installed
2. `cd backend && npx tsc --noEmit` compiles without errors
  </verify>
  <done>@hono/zod-validator installed, auth routes mounted at /auth/*</done>
</task>

<task type="auto">
  <name>Task 3: Add CORS configuration for auth routes</name>
  <files>backend/src/app.ts</files>
  <action>
Update app.ts to add CORS middleware for cross-origin cookie support:

```typescript
import { Hono } from 'hono'
import { logger } from 'hono/logger'
import { cors } from 'hono/cors'
import { routes } from './routes/index.js'
import { env } from './config/env.js'

const app = new Hono()

// Middleware
app.use('*', logger())

// CORS configuration for cookie-based auth
app.use('*', cors({
  origin: env.FRONTEND_URL,
  credentials: true,
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowHeaders: ['Content-Type'],
  maxAge: 86400,
}))

// Mount routes
app.route('/', routes)

export { app }
```

Key points:
- credentials: true required for cookies
- origin must match FRONTEND_URL exactly (no wildcards with credentials)
- allowHeaders includes Content-Type for JSON requests
  </action>
  <verify>
1. `cd backend && npx tsc --noEmit` compiles without errors
2. `cd backend && npm run dev` starts server (if DB available)
  </verify>
  <done>CORS configured for cookie-based authentication</done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors
2. @hono/zod-validator installed
3. Auth routes mounted at /auth/*
4. CORS configured for credentials
</verification>

<success_criteria>
- POST /auth/signup creates user and sends verification email
- POST /auth/login validates credentials, sets HTTP-only cookies
- POST /auth/logout clears cookies and invalidates session
- POST /auth/refresh rotates tokens
- GET /auth/me returns current user (requires auth)
- CORS allows credentials from FRONTEND_URL
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-04-SUMMARY.md`
</output>
