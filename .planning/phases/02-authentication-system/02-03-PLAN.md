---
phase: 02-authentication-system
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - backend/src/services/auth.service.ts
  - backend/src/middleware/auth.ts
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "Passwords are hashed with Argon2id before storage"
    - "JWT access tokens are generated with user ID and tier in payload"
    - "Auth middleware extracts and validates JWT from HTTP-only cookie"
    - "Protected routes receive userId and userTier from context"
  artifacts:
    - path: "backend/src/services/auth.service.ts"
      provides: "Password hashing and JWT generation"
      exports: ["hashPassword", "verifyPassword", "generateAccessToken", "generateRefreshToken"]
    - path: "backend/src/middleware/auth.ts"
      provides: "JWT verification middleware"
      exports: ["authMiddleware", "optionalAuthMiddleware", "requireTier"]
  key_links:
    - from: "backend/src/middleware/auth.ts"
      to: "hono/jwt"
      via: "JWT verification"
      pattern: "verify.*JWT_SECRET"
    - from: "backend/src/services/auth.service.ts"
      to: "argon2"
      via: "Password hashing"
      pattern: "argon2\\.hash|argon2\\.verify"
---

<objective>
Create authentication service (password hashing, JWT generation) and auth middleware for protecting routes.

Purpose: Provide core authentication logic that routes will use - secure password storage and JWT-based session management.
Output: auth.service.ts with password/JWT functions, auth middleware with route protection.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-system/02-RESEARCH.md
@.planning/phases/02-authentication-system/02-02-SUMMARY.md

# Existing patterns
@backend/src/config/env.ts
@backend/src/routes/health.ts
@backend/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install argon2 and create auth service</name>
  <files>backend/src/services/auth.service.ts, backend/package.json</files>
  <action>
First install argon2: `cd backend && npm install argon2`

Then create auth.service.ts:

```typescript
import argon2 from 'argon2'
import { sign } from 'hono/jwt'
import { env } from '../config/env.js'
import { generateToken, hashToken, daysFromNow, minutesFromNow } from './token.service.js'

// Argon2id configuration per OWASP 2026 recommendations
const ARGON2_CONFIG = {
  type: argon2.argon2id,
  memoryCost: 25600,  // ~25MB RAM
  timeCost: 3,        // 3 iterations
  parallelism: 1,     // Single thread
}

/**
 * Hash a password using Argon2id
 */
export async function hashPassword(password: string): Promise<string> {
  return argon2.hash(password, ARGON2_CONFIG)
}

/**
 * Verify a password against stored hash
 */
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  try {
    return await argon2.verify(hash, password)
  } catch {
    return false
  }
}

/**
 * JWT payload structure
 */
export interface JwtPayload {
  sub: number       // User ID
  tier: string      // User tier
  exp: number       // Expiration timestamp
  iat: number       // Issued at timestamp
}

/**
 * Generate JWT access token (short-lived, 15 min default)
 */
export async function generateAccessToken(
  userId: number,
  tier: string
): Promise<string> {
  const now = Math.floor(Date.now() / 1000)
  const payload: JwtPayload = {
    sub: userId,
    tier,
    iat: now,
    exp: now + env.JWT_ACCESS_EXPIRES_MINUTES * 60,
  }

  return sign(payload, env.JWT_SECRET)
}

/**
 * Generate refresh token (random string, stored hashed in DB)
 * Returns both raw token (for cookie) and hash (for DB storage)
 */
export function generateRefreshToken(): { token: string; hash: string; expiresAt: Date } {
  const token = generateToken(32)
  const hash = hashToken(token)
  const expiresAt = daysFromNow(env.JWT_REFRESH_EXPIRES_DAYS)

  return { token, hash, expiresAt }
}

/**
 * User tiers for access control
 */
export type UserTier = 'anonymous' | 'free' | 'member'

export const TIER_LEVELS: Record<UserTier, number> = {
  anonymous: 0,
  free: 1,
  member: 2,
}
```

Key points:
- Argon2id config matches OWASP 2026 recommendations
- JWT uses Hono's built-in sign function
- Refresh tokens are random strings, not JWTs
- Tier levels numeric for easy comparison
  </action>
  <verify>
1. `cd backend && npm ls argon2` shows argon2 installed
2. `cd backend && npx tsx -e "
import { hashPassword, verifyPassword } from './src/services/auth.service.js'
const hash = await hashPassword('testpassword')
console.log('Hash starts with argon2:', hash.startsWith('\$argon2'))
console.log('Verify correct:', await verifyPassword('testpassword', hash))
console.log('Verify wrong:', await verifyPassword('wrongpassword', hash))
"` prints all true/false correctly
  </verify>
  <done>auth.service.ts created with password and JWT functions, argon2 installed</done>
</task>

<task type="auto">
  <name>Task 2: Create authentication middleware</name>
  <files>backend/src/middleware/auth.ts</files>
  <action>
Create middleware directory and auth.ts:

```typescript
import { Context, Next } from 'hono'
import { verify } from 'hono/jwt'
import { getCookie } from 'hono/cookie'
import { env } from '../config/env.js'
import { JwtPayload, UserTier, TIER_LEVELS } from '../services/auth.service.js'

/**
 * Context variables set by auth middleware
 */
export interface AuthVariables {
  userId: number
  userTier: UserTier
  jwtPayload: JwtPayload
}

/**
 * Required authentication middleware
 * Returns 401 if no valid token present
 */
export async function authMiddleware(c: Context, next: Next) {
  const token = getCookie(c, 'access_token')

  if (!token) {
    return c.json({ error: 'Authentication required' }, 401)
  }

  try {
    const payload = await verify(token, env.JWT_SECRET) as JwtPayload

    // Set context variables for downstream handlers
    c.set('userId', payload.sub)
    c.set('userTier', payload.tier as UserTier)
    c.set('jwtPayload', payload)

    await next()
  } catch (err) {
    return c.json({ error: 'Invalid or expired token' }, 401)
  }
}

/**
 * Optional authentication middleware
 * Sets user context if token present, continues without if not
 */
export async function optionalAuthMiddleware(c: Context, next: Next) {
  const token = getCookie(c, 'access_token')

  if (token) {
    try {
      const payload = await verify(token, env.JWT_SECRET) as JwtPayload
      c.set('userId', payload.sub)
      c.set('userTier', payload.tier as UserTier)
      c.set('jwtPayload', payload)
    } catch {
      // Token invalid but optional, continue without auth
      c.set('userTier', 'anonymous' as UserTier)
    }
  } else {
    c.set('userTier', 'anonymous' as UserTier)
  }

  await next()
}

/**
 * Tier-based authorization middleware factory
 * Use after authMiddleware to require minimum tier level
 */
export function requireTier(minTier: UserTier) {
  return async (c: Context, next: Next) => {
    const userTier = c.get('userTier') as UserTier

    if (!userTier || TIER_LEVELS[userTier] < TIER_LEVELS[minTier]) {
      return c.json({
        error: 'Insufficient permissions',
        required: minTier,
        current: userTier || 'anonymous'
      }, 403)
    }

    await next()
  }
}

/**
 * Helper type for Hono app with auth variables
 */
export type AuthEnv = {
  Variables: AuthVariables
}
```

Key points:
- Three middleware types: required, optional, tier-based
- Uses Hono's getCookie helper (no extra package needed)
- Sets typed context variables for route handlers
- Tier comparison uses numeric levels
  </action>
  <verify>
`cd backend && npx tsc --noEmit` compiles without errors
  </verify>
  <done>auth.ts middleware created with authMiddleware, optionalAuthMiddleware, requireTier</done>
</task>

</tasks>

<verification>
1. argon2 package installed in backend/package.json
2. Password hashing works (create hash, verify correct, verify wrong)
3. All TypeScript compiles without errors
4. Middleware exports correct functions
</verification>

<success_criteria>
- auth.service.ts: hashPassword, verifyPassword, generateAccessToken, generateRefreshToken work correctly
- auth.ts middleware: authMiddleware, optionalAuthMiddleware, requireTier exported
- Argon2 uses recommended OWASP config
- JWT uses Hono's built-in sign/verify
- All TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-03-SUMMARY.md`
</output>
