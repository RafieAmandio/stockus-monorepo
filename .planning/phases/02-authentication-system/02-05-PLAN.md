---
phase: 02-authentication-system
plan: 05
type: execute
wave: 4
depends_on: ["02-04"]
files_modified:
  - backend/src/routes/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can verify email via token link"
    - "User can request password reset via email"
    - "User can reset password with valid token"
    - "Expired tokens are rejected"
    - "Tokens are single-use (deleted after use)"
  artifacts:
    - path: "backend/src/routes/auth.ts"
      provides: "Verification and reset endpoints"
      exports: ["auth"]
  key_links:
    - from: "backend/src/routes/auth.ts"
      to: "backend/src/services/email.service.ts"
      via: "sending emails"
      pattern: "sendVerificationEmail|sendPasswordResetEmail"
    - from: "backend/src/routes/auth.ts"
      to: "backend/src/db/schema/tokens.ts"
      via: "token storage"
      pattern: "tokens.*email_verification|password_reset"
---

<objective>
Add email verification and password reset flows to auth routes.

Purpose: Complete the authentication system with email-based account verification and password recovery.
Output: GET /verify-email, POST /forgot-password, POST /reset-password, POST /resend-verification endpoints.
</objective>

<execution_context>
@/Users/dio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-system/02-RESEARCH.md
@.planning/phases/02-authentication-system/02-04-SUMMARY.md

# Current auth routes
@backend/src/routes/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email verification endpoint</name>
  <files>backend/src/routes/auth.ts</files>
  <action>
Add to auth.ts (after the existing routes):

```typescript
/**
 * GET /auth/verify-email
 * Verify email using token from email link
 */
auth.get('/verify-email', async (c) => {
  const token = c.req.query('token')

  if (!token) {
    return c.json({ error: 'Verification token required' }, 400)
  }

  const tokenHash = hashToken(token)

  // Find valid token
  const tokenRecord = await db.query.tokens.findFirst({
    where: and(
      eq(tokens.tokenHash, tokenHash),
      eq(tokens.type, 'email_verification'),
      gt(tokens.expiresAt, new Date())
    ),
  })

  if (!tokenRecord) {
    return c.json({ error: 'Invalid or expired verification token' }, 400)
  }

  // Update user and delete token in transaction
  await db.transaction(async (tx) => {
    await tx.update(users)
      .set({ isVerified: true })
      .where(eq(users.id, tokenRecord.userId))

    await tx.delete(tokens).where(eq(tokens.id, tokenRecord.id))
  })

  return c.json({ message: 'Email verified successfully. You can now log in.' })
})

/**
 * POST /auth/resend-verification
 * Resend verification email for unverified user
 */
auth.post('/resend-verification', zValidator('json', z.object({
  email: z.string().email(),
})), async (c) => {
  const { email } = c.req.valid('json')

  // Find unverified user
  const user = await db.query.users.findFirst({
    where: eq(users.email, email.toLowerCase()),
  })

  // Always return success to prevent enumeration
  if (user && !user.isVerified) {
    // Delete any existing verification tokens
    await db.delete(tokens).where(
      and(
        eq(tokens.userId, user.id),
        eq(tokens.type, 'email_verification')
      )
    )

    // Generate new token
    const verificationToken = generateToken()
    const tokenHash = hashToken(verificationToken)

    await db.insert(tokens).values({
      userId: user.id,
      type: 'email_verification',
      tokenHash,
      expiresAt: hoursFromNow(24),
    })

    sendVerificationEmail(user.email, verificationToken, user.name).catch(err => {
      console.error('Failed to send verification email:', err)
    })
  }

  return c.json({ message: 'If your account exists and is unverified, a new verification email has been sent.' })
})
```

Key points:
- GET endpoint for email links (easy click from email)
- Transaction ensures atomic update + delete
- Generic response prevents email enumeration
- Delete existing tokens before creating new one
  </action>
  <verify>`cd backend && npx tsc --noEmit` compiles without errors</verify>
  <done>verify-email and resend-verification endpoints added</done>
</task>

<task type="auto">
  <name>Task 2: Add password reset flow</name>
  <files>backend/src/routes/auth.ts</files>
  <action>
Add to auth.ts (after verification endpoints):

```typescript
import { sendPasswordResetEmail, sendPasswordChangedEmail } from '../services/email.service.js'

// Add to validation schemas section at top
const resetPasswordSchema = z.object({
  token: z.string(),
  newPassword: z.string().min(8, 'Password must be at least 8 characters'),
})

/**
 * POST /auth/forgot-password
 * Send password reset email
 */
auth.post('/forgot-password', zValidator('json', z.object({
  email: z.string().email(),
})), async (c) => {
  const { email } = c.req.valid('json')

  // Find user
  const user = await db.query.users.findFirst({
    where: eq(users.email, email.toLowerCase()),
  })

  // Always return success to prevent enumeration
  if (user) {
    // Delete any existing password reset tokens for this user
    await db.delete(tokens).where(
      and(
        eq(tokens.userId, user.id),
        eq(tokens.type, 'password_reset')
      )
    )

    // Generate reset token
    const resetToken = generateToken()
    const tokenHash = hashToken(resetToken)

    await db.insert(tokens).values({
      userId: user.id,
      type: 'password_reset',
      tokenHash,
      expiresAt: hoursFromNow(1), // 1 hour expiry for password reset
    })

    sendPasswordResetEmail(user.email, resetToken).catch(err => {
      console.error('Failed to send password reset email:', err)
    })
  }

  return c.json({ message: 'If an account exists with this email, a password reset link has been sent.' })
})

/**
 * POST /auth/reset-password
 * Reset password using token
 */
auth.post('/reset-password', zValidator('json', resetPasswordSchema), async (c) => {
  const { token, newPassword } = c.req.valid('json')

  const tokenHash = hashToken(token)

  // Find valid token
  const tokenRecord = await db.query.tokens.findFirst({
    where: and(
      eq(tokens.tokenHash, tokenHash),
      eq(tokens.type, 'password_reset'),
      gt(tokens.expiresAt, new Date())
    ),
  })

  if (!tokenRecord) {
    return c.json({ error: 'Invalid or expired reset token' }, 400)
  }

  // Get user for email notification
  const user = await db.query.users.findFirst({
    where: eq(users.id, tokenRecord.userId),
  })

  if (!user) {
    return c.json({ error: 'User not found' }, 400)
  }

  // Hash new password
  const passwordHash = await hashPassword(newPassword)

  // Update password, delete all tokens, invalidate all sessions
  await db.transaction(async (tx) => {
    // Update password
    await tx.update(users)
      .set({ passwordHash })
      .where(eq(users.id, tokenRecord.userId))

    // Delete ALL password reset tokens for this user
    await tx.delete(tokens).where(
      and(
        eq(tokens.userId, tokenRecord.userId),
        eq(tokens.type, 'password_reset')
      )
    )

    // Invalidate all sessions (force re-login)
    await tx.delete(sessions).where(eq(sessions.userId, tokenRecord.userId))
  })

  // Send notification email
  sendPasswordChangedEmail(user.email).catch(err => {
    console.error('Failed to send password changed email:', err)
  })

  return c.json({ message: 'Password reset successful. Please log in with your new password.' })
})
```

Key points:
- Password reset tokens expire in 1 hour (shorter than verification)
- All sessions invalidated after password change (security best practice)
- Notification email sent after password change
- Generic responses prevent enumeration
- Transaction ensures atomic operations
  </action>
  <verify>`cd backend && npx tsc --noEmit` compiles without errors</verify>
  <done>forgot-password and reset-password endpoints added</done>
</task>

<task type="auto">
  <name>Task 3: Add validation token endpoint for frontend</name>
  <files>backend/src/routes/auth.ts</files>
  <action>
Add endpoint for frontend to validate reset token before showing password form:

```typescript
/**
 * GET /auth/validate-reset-token
 * Validate password reset token (for frontend to check before showing form)
 */
auth.get('/validate-reset-token', async (c) => {
  const token = c.req.query('token')

  if (!token) {
    return c.json({ valid: false, error: 'Token required' }, 400)
  }

  const tokenHash = hashToken(token)

  const tokenRecord = await db.query.tokens.findFirst({
    where: and(
      eq(tokens.tokenHash, tokenHash),
      eq(tokens.type, 'password_reset'),
      gt(tokens.expiresAt, new Date())
    ),
  })

  if (!tokenRecord) {
    return c.json({ valid: false, error: 'Invalid or expired token' })
  }

  return c.json({ valid: true })
})
```

This allows the frontend to:
1. Check token validity before showing reset form
2. Display appropriate error if token expired
3. Avoid wasted form submission on invalid tokens
  </action>
  <verify>`cd backend && npx tsc --noEmit` compiles without errors</verify>
  <done>validate-reset-token endpoint added for UX improvement</done>
</task>

</tasks>

<verification>
1. All TypeScript compiles without errors
2. Auth routes exports all endpoints
3. Token operations use transactions where appropriate
4. Generic responses used to prevent enumeration
</verification>

<success_criteria>
- GET /auth/verify-email verifies email and marks user as verified
- POST /auth/resend-verification sends new verification email
- POST /auth/forgot-password sends reset email (generic response)
- POST /auth/reset-password resets password and invalidates sessions
- GET /auth/validate-reset-token checks if reset token is valid
- Tokens are single-use (deleted after successful use)
- Expired tokens return appropriate errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-05-SUMMARY.md`
</output>
